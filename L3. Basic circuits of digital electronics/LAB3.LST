0001   0000             
0002   0000             ;ШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШ
0003   0000             ;ШШШШШШШ  Программа для проверки работы транслятора TASM  ШШШШШШШ
0004   0000             ;ШШШШШШШ    с системой команд модели процессора MDP-08    ШШШШШШШ
0005   0000             ;ШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШ
0006   0000             ; Test all instructions and addressing modes.
0007   0000             ; Processor: MDP08
0008   0000             ;
0009   0000             		.ORG	000h	; Назначение начального адреса трансляции
0010   0000             ;----------------------------------------------------------------
0011   0000 43 80       M6:		INS     D, #80h ; маска для числа х	у старшому розряді		
0012   0002 0C          		WRITE   A, D    ; отримуємо старший розряд для х
0013   0003 24          		INV     A, A    ; інвертуємо його
0014   0004 38          		RR      A, A    ; потім зміщуємо циклічно 4 рази вправо
0015   0005 38          		RR      A, A    ; щоб "прибрати" чотири 1 в старших розрядах,
0016   0006 38          		RR      A, A    ; треба буде створити маску
0017   0007 38          		RR      A, A    ;
0018   0008 41 08       		INS     B, #08h ; в регістр B заносимо маску і перемножуємо
0019   000A 2D          		AND     B, AB   ; отримуємо інверсію біта числа х в регістрі В в молодших байтах
0020   000B             		
0021   000B 43 08       		INS     D, #08h ; нова маска для старшого біту числа у
0022   000D 0C          		WRITE   A, D    ; зчитуємо в регістр А цей біт
0023   000E 30          		XOR     A, AB   ; перевіряємо на рівність відповідні біти з х та у
0024   000F C0 48       		GOZR	M1      ; якщо не рівні, тоді йдемо на мітку М1
0025   0011             		
0026   0011             		
0027   0011 43 40       		INS     D, #40h ; маска для наступного біту числа х
0028   0013 0C          		WRITE   A, D    ; повторення
0029   0014 24          		INV     A, A    ; 
0030   0015 38          		RR      A, A    ; 
0031   0016 38          		RR      A, A    ; 
0032   0017 38          		RR      A, A    ; 
0033   0018 38          		RR      A, A    ;
0034   0019 41 04       		INS     B, #04h ; 
0035   001B 2D          		AND     B, AB   ; записуємо інверсію біта в регістр В
0036   001C             		
0037   001C 43 04       		INS     D, #04h ; нова маска для наступного біту числа у
0038   001E 0C          		WRITE   A, D    ; зчитуємо в регістр А цей біт
0039   001F 30          		XOR     A, AB   ; перевіряємо на рівність відповідні біти з х та у
0040   0020 C0 48       		GOZR	M1      ; якщо не рівні, тоді йдемо на мітку М1
0041   0022             		
0042   0022             		
0043   0022 43 20       		INS     D, #20h ; маска для наступного біту числа х
0044   0024 0C          		WRITE   A, D    ; повторення
0045   0025 24          		INV     A, A    ; 
0046   0026 38          		RR      A, A    ; 
0047   0027 38          		RR      A, A    ; 
0048   0028 38          		RR      A, A    ; 
0049   0029 38          		RR      A, A    ;
0050   002A 41 02       		INS     B, #02h ; 
0051   002C 2D          		AND     B, AB   ; записуємо інверсію біта в регістр В
0052   002D             		
0053   002D 43 02       		INS     D, #02h ; нова маска для наступного біту числа у
0054   002F 0C          		WRITE   A, D    ; зчитуємо в регістр А цей біт
0055   0030 30          		XOR     A, AB   ; перевіряємо на рівність відповідні біти з х та у
0056   0031 C0 48       		GOZR	M1      ; якщо не рівні, тоді йдемо на мітку М1
0057   0033             		
0058   0033             		
0059   0033 43 10       		INS     D, #10h ; маска для наступного біту числа х
0060   0035 0C          		WRITE   A, D    ; повторення
0061   0036 24          		INV     A, A    ; 
0062   0037 38          		RR      A, A    ; 
0063   0038 38          		RR      A, A    ; 
0064   0039 38          		RR      A, A    ; 
0065   003A 38          		RR      A, A    ;
0066   003B 41 01       		INS     B, #01h ; 
0067   003D 2D          		AND     B, AB   ; записуємо інверсію біта в регістр В
0068   003E             		
0069   003E 43 01       		INS     D, #01h ; нова маска для наступного біту числа у
0070   0040 0C          		WRITE   A, D    ; зчитуємо в регістр А цей біт
0071   0041 30          		XOR     A, AB   ; перевіряємо на рівність відповідні біти з х та у
0072   0042 C0 48       		GOZR    M1      ; якщо не рівні, тоді йдемо на мітку М1
0073   0044             		
0074   0044 42 18       		INS     C, #18h ; пишемо в регістр С, що х дорівнює у
0075   0046 80 52       		GOTO    M4      ; переходимо в кінець
0076   0048             		
0077   0048 0C          M1:		WRITE   A, D    ; "повертаємо" А, бо там зараз результат XOR
0078   0049 2C          		AND     A, AB   ; біти не рівні. Перевіряємо, чи більший біт числа х за біт числа у
0079   004A C0 50       		GOZR    M2      ; якщо біт х більше, переходимо на мітку М2
0080   004C             		
0081   004C 42 03       		INS     C, #03h ; якщо біт х менше за біт у, пишемо це в регістр		
0082   004E 80 52       		GOTO    M4      ; переходимо в кінець
0083   0050             		
0084   0050 42 C0       M2:     INS     C, #0C0h; пишемо в регістр С, що х більше за у
0085   0052             
0086   0052 43 FF       M4:		INS     D, #0FFh; перевірка на зміну клавіатури
0087   0054 0D          		WRITE   B, D    ;
0088   0055             		
0089   0055 0C          M5:		WRITE   A, D    ;
0090   0056 30          		XOR     A, AB   ; якщо А = 0, нічого не змінилось і перевіряємо стан ще раз
0091   0057 C0 55       		GOZR    M5      ; перевіряємо стан ще раз
0092   0059 C1 00       		GONZR   M6      ; якщо А не 0, ще раз зчитуємо клавіатуру
0093   005B             		
0094   005B             ;----------------------------------------------------------------
0095   005B                     .END			; кінець програми
tasm: Number of errors = 0
