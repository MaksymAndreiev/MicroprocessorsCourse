0001   0000             
0002   0000             ;ШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШ
0003   0000             ;ШШШШШШШ  Программа для проверки работы транслятора TASM  ШШШШШШШ
0004   0000             ;ШШШШШШШ    с системой команд модели процессора MDP-08    ШШШШШШШ
0005   0000             ;ШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШ
0006   0000             ; Test all instructions and addressing modes.
0007   0000             ; Processor: MDP08
0008   0000             ;   
0009   0000             		.ORG	   000h      ; Назначение начального адреса трансляции
0010   0000             ;----------------------------------------------------------------
0011   0000                     #Include   MACROS.ASM; 
0001+  0000             ; ==================== БІБЛІОТЕКА МАКРОПРОЦЕДУР ПРОГРАМИ «Lab3_2» ======================
0002+  0000             
0003+  0000             ;       .NOLIST
0004+  0000             
0005+  0000             ;-------------------------------------------------------------------------------------------------------------------
0006+  0000             #DEFINE  InitStart(Dm)	INS	  B, #Dm		; маска для числа х	у старшому розряді
0007+  0000             #DEFCONT \				WRITE A, D			; отримуємо старший розряд для х
0008+  0000             #DEFCONT \				INV	  A, A			; інвертуємо його
0009+  0000             #DEFCONT \				RR	  A, A			; потім зміщуємо циклічно 4 рази вправо
0010+  0000             #DEFCONT \				RR	  A, A			; щоб "прибрати" чотири 1 в старших розрядах,
0011+  0000             #DEFCONT \				RR	  A, A			; треба буде створити маску
0012+  0000             #DEFCONT \				RR	  A, A			;
0013+  0000             
0014+  0000             ;-------------------------------------------------------------------------------------------------------------------
0015+  0000             ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0016+  0000             #DEFINE  InitAndEq(Dm)     INS     B, #Dm  ; в регістр B заносимо маску і перемножуєм
0017+  0000             #DEFCONT \                 AND     B, AB   ; отримуємо інверсію біта числа х в регістрі В в молодших байтах
0018+  0000             #DEFCONT \                 INS     D, #Dm  ; нова маска для старшого біту числа у
0019+  0000             #DEFCONT \                 WRITE   A, D    ; зчитуємо в регістр А цей біт
0020+  0000             #DEFCONT \                 XOR     A, AB   ; перевіряємо на рівність відповідні біти з х та у
0021+  0000             ;-------------------------------------------------------------------------------------------------------------------
0022+  0000             ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0023+  0000             #DEFINE  BiggerORSmaller() WRITE   A, D    ; "повертаємо" А, бо там зараз результат XOR
0024+  0000             #DEFCONT \                 AND     A, AB   ; біти не рівні. Перевіряємо, чи більший біт числа х за біт числа у
0025+  0000             #DEFCONT \                 GOZR    *+4     ; якщо біт х більше, переходимо на мітку М2
0026+  0000             #DEFCONT \                 INS     C, #03h ; якщо біт х менше за біт у, пишемо це в регістр
0027+  0000             #DEFCONT \                 GOTO    *+4     ; переходимо в кінець
0028+  0000             #DEFCONT \                 INS     C, #0C0h; пишемо в регістр С, що х більше за у              
0029+  0000             ;-------------------------------------------------------------------------------------------------------------------
0030+  0000             ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0031+  0000             #DEFINE Changes()          INS     D, #0FFh; перевірка на зміну клавіатури
0032+  0000             #DEFCONT \                 WRITE   B, D    ;
0033+  0000             #DEFCONT \                 WRITE   A, D    ;
0034+  0000             #DEFCONT \                 XOR     A, AB   ; якщо А = 0, нічого не змінилось і перевіряємо стан ще раз
0035+  0000             #DEFCONT \                 GOZR    *-2     ; перевіряємо стан ще раз
0036+  0000             ;-------------------------------------------------------------------------------------------------------------------
0037+  0000             ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0038+  0000             
0039+  0000             ;       .LIST
0012   0000             ;----------------------------------------------------------------
0013   0000 41 80       Start:	InitStart(80h)       ; функція ініціалізації потрібних бітів і їх порівняння
0013   0002 0C          
0013   0003 24          
0013   0004 38          
0013   0005 38          
0013   0006 38          
0013   0007 38          
0014   0008 41 08       		InitAndEq(08h)       ;
0014   000A 2D          
0014   000B 43 08       
0014   000D 0C          
0014   000E 30          
0015   000F C0 48       		GOZR       M1        ; якщо не рівні, тоді йдемо на мітку М1
0016   0011             		
0017   0011 41 40       		InitStart(40h)       ;
0017   0013 0C          
0017   0014 24          
0017   0015 38          
0017   0016 38          
0017   0017 38          
0017   0018 38          
0018   0019 41 04       		InitAndEq(04h)       ;
0018   001B 2D          
0018   001C 43 04       
0018   001E 0C          
0018   001F 30          
0019   0020 C0 48       		GOZR       M1        ; 
0020   0022             		
0021   0022 41 20       		InitStart(20h)       ;
0021   0024 0C          
0021   0025 24          
0021   0026 38          
0021   0027 38          
0021   0028 38          
0021   0029 38          
0022   002A 41 02       		InitAndEq(02h)       ;
0022   002C 2D          
0022   002D 43 02       
0022   002F 0C          
0022   0030 30          
0023   0031 C0 48       		GOZR	   M1        ; 
0024   0033             		
0025   0033 41 10       		InitStart(10h)       ;
0025   0035 0C          
0025   0036 24          
0025   0037 38          
0025   0038 38          
0025   0039 38          
0025   003A 38          
0026   003B 41 01       		InitAndEq(01h)       ;
0026   003D 2D          
0026   003E 43 01       
0026   0040 0C          
0026   0041 30          
0027   0042 C0 48       		GOZR       M1        ; 
0028   0044             		
0029   0044 42 18       		INS       C, #18h    ; у випадку рівності, пишемо в регістр С, що х дорівнює у
0030   0046 80 52       		GOTO      M4         ; переходимо в кінець
0031   0048             		
0032   0048 0C          M1:		BiggerORSmaller()    ; функція порівняння
0032   0049 2C          
0032   004A C0 4E       
0032   004C 42 03       
0032   004E 80 52       
0032   0050 42 C0       
0033   0052 43 FF       M4:		Changes()            ; функція відслідковує зміни клавіатури
0033   0054 0D          
0033   0055 0C          
0033   0056 30          
0033   0057 C0 55       
0034   0059 80 00       		GOTO      Start      ; якщо були зміни, ще раз зчитуємо клавіатуру
0035   005B             ;----------------------------------------------------------------
0036   005B                     .END			; кінець програми
tasm: Number of errors = 0
