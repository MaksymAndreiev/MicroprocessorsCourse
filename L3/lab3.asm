
;ШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШ
;ШШШШШШШ  Программа для проверки работы транслятора TASM  ШШШШШШШ
;ШШШШШШШ    с системой команд модели процессора MDP-08    ШШШШШШШ
;ШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШШ
; Test all instructions and addressing modes.
; Processor: MDP08
;
		.ORG	000h	; Назначение начального адреса трансляции
;----------------------------------------------------------------
M6:		INS     D, #80h ; маска для числа х	у старшому розряді		
		WRITE   A, D    ; отримуємо старший розряд для х
		INV     A, A    ; інвертуємо його
		RR      A, A    ; потім зміщуємо циклічно 4 рази вправо
		RR      A, A    ; щоб "прибрати" чотири 1 в старших розрядах,
		RR      A, A    ; треба буде створити маску
		RR      A, A    ;
		INS     B, #08h ; в регістр B заносимо маску і перемножуємо
		AND     B, AB   ; отримуємо інверсію біта числа х в регістрі В в молодших байтах
		
		INS     D, #08h ; нова маска для старшого біту числа у
		WRITE   A, D    ; зчитуємо в регістр А цей біт
		XOR     A, AB   ; перевіряємо на рівність відповідні біти з х та у
		GOZR	M1      ; якщо не рівні, тоді йдемо на мітку М1
		
		
		INS     D, #40h ; маска для наступного біту числа х
		WRITE   A, D    ; повторення
		INV     A, A    ; 
		RR      A, A    ; 
		RR      A, A    ; 
		RR      A, A    ; 
		RR      A, A    ;
		INS     B, #04h ; 
		AND     B, AB   ; записуємо інверсію біта в регістр В
		
		INS     D, #04h ; нова маска для наступного біту числа у
		WRITE   A, D    ; зчитуємо в регістр А цей біт
		XOR     A, AB   ; перевіряємо на рівність відповідні біти з х та у
		GOZR	M1      ; якщо не рівні, тоді йдемо на мітку М1
		
		
		INS     D, #20h ; маска для наступного біту числа х
		WRITE   A, D    ; повторення
		INV     A, A    ; 
		RR      A, A    ; 
		RR      A, A    ; 
		RR      A, A    ; 
		RR      A, A    ;
		INS     B, #02h ; 
		AND     B, AB   ; записуємо інверсію біта в регістр В
		
		INS     D, #02h ; нова маска для наступного біту числа у
		WRITE   A, D    ; зчитуємо в регістр А цей біт
		XOR     A, AB   ; перевіряємо на рівність відповідні біти з х та у
		GOZR	M1      ; якщо не рівні, тоді йдемо на мітку М1
		
		
		INS     D, #10h ; маска для наступного біту числа х
		WRITE   A, D    ; повторення
		INV     A, A    ; 
		RR      A, A    ; 
		RR      A, A    ; 
		RR      A, A    ; 
		RR      A, A    ;
		INS     B, #01h ; 
		AND     B, AB   ; записуємо інверсію біта в регістр В
		
		INS     D, #01h ; нова маска для наступного біту числа у
		WRITE   A, D    ; зчитуємо в регістр А цей біт
		XOR     A, AB   ; перевіряємо на рівність відповідні біти з х та у
		GOZR    M1      ; якщо не рівні, тоді йдемо на мітку М1
		
		INS     C, #18h ; пишемо в регістр С, що х дорівнює у
		GOTO    M4      ; переходимо в кінець
		
M1:		WRITE   A, D    ; "повертаємо" А, бо там зараз результат XOR
		AND     A, AB   ; біти не рівні. Перевіряємо, чи більший біт числа х за біт числа у
		GOZR    M2      ; якщо біт х більше, переходимо на мітку М2
		
		INS     C, #03h ; якщо біт х менше за біт у, пишемо це в регістр		
		GOTO    M4      ; переходимо в кінець
		
M2:     INS     C, #0C0h; пишемо в регістр С, що х більше за у

M4:		INS     D, #0FFh; перевірка на зміну клавіатури
		WRITE   B, D    ;
		
M5:		WRITE   A, D    ;
		XOR     A, AB   ; якщо А = 0, нічого не змінилось і перевіряємо стан ще раз
		GOZR    M5      ; перевіряємо стан ще раз
		GONZR   M6      ; якщо А не 0, ще раз зчитуємо клавіатуру
		
;----------------------------------------------------------------
        .END			; кінець програми
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~